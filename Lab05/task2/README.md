# Лабораторная 5.2: Типизация состояния и обработчиков событий

## Почему `React.ChangeEvent`, а не `any`?

Использование `React.ChangeEvent<HTMLInputElement>` вместо `any`:

1. **Типобезопасность** — TypeScript гарантирует доступ только к существующим свойствам (например, `event.target.value`).
2. **Проверка на этапе компиляции** — опечатки и неверный доступ к свойствам отлавливаются до запуска кода.
3. **Поддержка IDE** — автодополнение и документация для объекта события.
4. **Без `any`** — задание запрещает использование `any`; типизированные события соответствуют этому требованию.

## Когда нужны явные дженерики, а когда — вывод типов

| Ситуация | Пример | Причина |
|----------|--------|---------|
| **Пустой массив** | `useState<User[]>([])` | TS выводит `never[]` из `[]`; нужен дженерик для указания `User[]`. |
| **null** | `useState<User \| null>(null)` | Аналогично: TS выводит только `null`; дженерик добавляет `User` в объединение. |
| **Примитив с начальным значением** | `useState("")` | TS выводит `string` из `""`; дженерик не нужен. |
| **Число с начальным значением** | `useState(0)` | TS выводит `number`; дженерик не нужен. |

**Правило:** используйте явные дженерики, когда начальное значение не содержит полного типа (пустые массивы, null). Полагайтесь на вывод типов, когда начальное значение полностью описывает тип.

## Запуск

```bash
npm install
npm run dev
```
